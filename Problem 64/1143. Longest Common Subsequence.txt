Link to Youtube Video :- 
Link to Leetcode problem :- https://leetcode.com/problems/longest-common-subsequence/description/?envType=study-plan-v2&envId=leetcode-75

Time Complexity :- O(N*M)
Space Complexity :- O(N*M)


##############-PYTHON Memoization-####################

class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        n = len(text1)
        m = len(text2)

        dp = [[-1 for _ in range(m)] for _ in range(n)]

        def fun(ind1: int, ind2: int) -> int:
            # Base case
            if ind1 < 0 or ind2 < 0:
                return 0

            if dp[ind1][ind2] != -1:
                return dp[ind1][ind2]

            if text1[ind1] == text2[ind2]:
                dp[ind1][ind2] = 1 + fun(ind1 - 1, ind2 - 1)
            else:
                dp[ind1][ind2] = max(fun(ind1 - 1, ind2), fun(ind1, ind2 - 1))
            return dp[ind1][ind2]

        return fun(n - 1, m - 1)


##############-PYTHON Tabular-####################

class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        n = len(text1)
        m = len(text2)

        dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]

        for i in range(1, n + 1):
            for j in range(1, m + 1):
                if text1[i - 1] == text2[j - 1]:
                    dp[i][j] = 1 + dp[i - 1][j - 1]
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

        return dp[n][m]

 
##############-C++ Memoization-####################

class Solution {
public:
    int fun(string& text1, string& text2, int ind1, int ind2, vector<vector<int>>& dp) {
        if (ind1 < 0 || ind2 < 0)
            return 0;

        if (dp[ind1][ind2] != -1)
            return dp[ind1][ind2];

        if (text1[ind1] == text2[ind2])
            return dp[ind1][ind2] = 1 + fun(text1, text2, ind1 - 1, ind2 - 1, dp);
        else
            return dp[ind1][ind2] = max(fun(text1, text2, ind1 - 1, ind2, dp),
                                        fun(text1, text2, ind1, ind2 - 1, dp));
    }

    int longestCommonSubsequence(string text1, string text2) {
        int n = text1.size();
        int m = text2.size();
        vector<vector<int>> dp(n, vector<int>(m, -1));
        return fun(text1, text2, n - 1, m - 1, dp);
    }
};


##############-C++ Tabular-####################

class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        n = len(text1)
        m = len(text2)

        dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]

        for i in range(1, n + 1):
            for j in range(1, m + 1):
                if text1[i - 1] == text2[j - 1]:
                    dp[i][j] = 1 + dp[i - 1][j - 1]
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

        return dp[n][m]




##############-Java Memoization-####################

class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int n = text1.length();
        int m = text2.length();
        int[][] dp = new int[n][m];

        for (int[] row : dp)
            Arrays.fill(row, -1);

        return fun(text1, text2, n - 1, m - 1, dp);
    }

    private int fun(String text1, String text2, int ind1, int ind2, int[][] dp) {
        if (ind1 < 0 || ind2 < 0)
            return 0;

        if (dp[ind1][ind2] != -1)
            return dp[ind1][ind2];

        if (text1.charAt(ind1) == text2.charAt(ind2))
            dp[ind1][ind2] = 1 + fun(text1, text2, ind1 - 1, ind2 - 1, dp);
        else
            dp[ind1][ind2] = Math.max(fun(text1, text2, ind1 - 1, ind2, dp),
                                      fun(text1, text2, ind1, ind2 - 1, dp));
        return dp[ind1][ind2];
    }
}


##############-Java Tabular-####################

class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int n = text1.length();
        int m = text2.length();

        int[][] dp = new int[n + 1][m + 1];

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[n][m];
    }
}

